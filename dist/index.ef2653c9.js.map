{"mappings":"ACkBA,QAAQ,GAAG,CADC,AEmHQ,CAAA,CAClB,EACA,EACA,EAAO,CAAA,CACJ,GACH,AAAK,EAGE,EAAM,KAAM,GAAE,IAAA,CAAK,AAAS,CAAA,IAAT,EADd,CAAC,EAAM,IAAS,EAAO,GAAK,EAAO,GADnC,CAAC,EAAM,IAAS,EAAO,GAAK,EAAO,IAD5B,EAAC,AAItB,EF1Ia,CACX,CACE,KAAM,SACN,OAAQ,GACV,EACA,CACE,KAAM,OACN,OAAQ,CACV,EACA,CACE,KAAM,QACN,OAAQ,EACV,EACD,CACsB,AAAA,GAAK,EAAE,MAAM","sources":["<anon>","src/js/script.js","node_modules/radash/dist/esm/array.mjs","node_modules/radash/src/array.ts","node_modules/radash/dist/esm/typed.mjs","node_modules/radash/src/typed.ts"],"sourcesContent":["const $8ec73ad99a2999b4$export$a244864fd9645c7f = (value)=>{\n    return !!value && value.constructor === Symbol;\n};\nconst $8ec73ad99a2999b4$export$43bee75e5e14138e = Array.isArray;\nconst $8ec73ad99a2999b4$export$a6cdc56e425d0d0a = (value)=>{\n    return !!value && value.constructor === Object;\n};\nconst $8ec73ad99a2999b4$export$c3825b437cbdea5c = (value)=>{\n    return value === void 0 || value === null || typeof value !== \"object\" && typeof value !== \"function\";\n};\nconst $8ec73ad99a2999b4$export$f6e2535fb5126e54 = (value)=>{\n    return !!(value && value.constructor && value.call && value.apply);\n};\nconst $8ec73ad99a2999b4$export$844ec244b1367d54 = (value)=>{\n    return typeof value === \"string\" || value instanceof String;\n};\nconst $8ec73ad99a2999b4$export$357fc28f6427af8b = (value)=>{\n    return $8ec73ad99a2999b4$export$7e4aa119212bc614(value) && value % 1 === 0;\n};\nconst $8ec73ad99a2999b4$export$4ba1d6600e2a2892 = (value)=>{\n    return $8ec73ad99a2999b4$export$7e4aa119212bc614(value) && value % 1 !== 0;\n};\nconst $8ec73ad99a2999b4$export$7e4aa119212bc614 = (value)=>{\n    try {\n        return Number(value) === value;\n    } catch  {\n        return false;\n    }\n};\nconst $8ec73ad99a2999b4$export$871608497c498473 = (value)=>{\n    return Object.prototype.toString.call(value) === \"[object Date]\";\n};\nconst $8ec73ad99a2999b4$export$4369c812aac99591 = (value)=>{\n    if (!value) return false;\n    if (!value.then) return false;\n    if (!$8ec73ad99a2999b4$export$f6e2535fb5126e54(value.then)) return false;\n    return true;\n};\nconst $8ec73ad99a2999b4$export$dd1bc94b04021eeb = (value)=>{\n    if (value === true || value === false) return true;\n    if (value === null || value === void 0) return true;\n    if ($8ec73ad99a2999b4$export$7e4aa119212bc614(value)) return value === 0;\n    if ($8ec73ad99a2999b4$export$871608497c498473(value)) return isNaN(value.getTime());\n    if ($8ec73ad99a2999b4$export$f6e2535fb5126e54(value)) return false;\n    if ($8ec73ad99a2999b4$export$a244864fd9645c7f(value)) return false;\n    const length = value.length;\n    if ($8ec73ad99a2999b4$export$7e4aa119212bc614(length)) return length === 0;\n    const size = value.size;\n    if ($8ec73ad99a2999b4$export$7e4aa119212bc614(size)) return size === 0;\n    const keys = Object.keys(value).length;\n    return keys === 0;\n};\nconst $8ec73ad99a2999b4$export$248d38f6296296c5 = (x, y)=>{\n    if (Object.is(x, y)) return true;\n    if (x instanceof Date && y instanceof Date) return x.getTime() === y.getTime();\n    if (x instanceof RegExp && y instanceof RegExp) return x.toString() === y.toString();\n    if (typeof x !== \"object\" || x === null || typeof y !== \"object\" || y === null) return false;\n    const keysX = Reflect.ownKeys(x);\n    const keysY = Reflect.ownKeys(y);\n    if (keysX.length !== keysY.length) return false;\n    for(let i = 0; i < keysX.length; i++){\n        if (!Reflect.has(y, keysX[i])) return false;\n        if (!$8ec73ad99a2999b4$export$248d38f6296296c5(x[keysX[i]], y[keysX[i]])) return false;\n    }\n    return true;\n};\n\n\nconst $1819a5bdd3dcc96d$export$e5e25fbcc1f7affe = (array, getGroupId)=>{\n    return array.reduce((acc, item)=>{\n        const groupId = getGroupId(item);\n        if (!acc[groupId]) acc[groupId] = [];\n        acc[groupId].push(item);\n        return acc;\n    }, {});\n};\nfunction $1819a5bdd3dcc96d$export$8901015135f2fb22(...arrays) {\n    if (!arrays || !arrays.length) return [];\n    return new Array(Math.max(...arrays.map(({ length: length })=>length))).fill([]).map((_, idx)=>arrays.map((array)=>array[idx]));\n}\nfunction $1819a5bdd3dcc96d$export$80f93f6a88298262(keys, values) {\n    if (!keys || !keys.length) return {};\n    const getValue = (0, $8ec73ad99a2999b4$export$f6e2535fb5126e54)(values) ? values : (0, $8ec73ad99a2999b4$export$43bee75e5e14138e)(values) ? (_k, i)=>values[i] : (_k, _i)=>values;\n    return keys.reduce((acc, key, idx)=>{\n        acc[key] = getValue(key, idx);\n        return acc;\n    }, {});\n}\nconst $1819a5bdd3dcc96d$export$b1830edfb6732669 = (array, compareFunc)=>{\n    if (!array || (array.length ?? 0) === 0) return null;\n    return array.reduce(compareFunc);\n};\nconst $1819a5bdd3dcc96d$export$8a63f25cc62965f1 = (array, fn)=>{\n    return (array || []).reduce((acc, item)=>acc + (fn ? fn(item) : item), 0);\n};\nconst $1819a5bdd3dcc96d$export$43128fadae87b74a = (array, defaultValue)=>{\n    return array?.length > 0 ? array[0] : defaultValue;\n};\nconst $1819a5bdd3dcc96d$export$4c7897fafd92b108 = (array, defaultValue)=>{\n    return array?.length > 0 ? array[array.length - 1] : defaultValue;\n};\nconst $1819a5bdd3dcc96d$export$97db5808d8f88186 = (array, getter, desc = false)=>{\n    if (!array) return [];\n    const asc = (a, b)=>getter(a) - getter(b);\n    const dsc = (a, b)=>getter(b) - getter(a);\n    return array.slice().sort(desc === true ? dsc : asc);\n};\nconst $1819a5bdd3dcc96d$export$cf575c749750f3b1 = (array, getter, dir = \"asc\")=>{\n    if (!array) return [];\n    const asc = (a, b)=>`${getter(a)}`.localeCompare(getter(b));\n    const dsc = (a, b)=>`${getter(b)}`.localeCompare(getter(a));\n    return array.slice().sort(dir === \"desc\" ? dsc : asc);\n};\nconst $1819a5bdd3dcc96d$export$76570820bc799110 = (list2, identity)=>{\n    if (!list2) return {};\n    return list2.reduce((acc, item)=>{\n        const id = identity(item);\n        acc[id] = (acc[id] ?? 0) + 1;\n        return acc;\n    }, {});\n};\nconst $1819a5bdd3dcc96d$export$77ad94ebf1c2b9ed = (list2, newItem, match)=>{\n    if (!list2) return [];\n    if (newItem === void 0) return [\n        ...list2\n    ];\n    for(let idx = 0; idx < list2.length; idx++){\n        const item = list2[idx];\n        if (match(item, idx)) return [\n            ...list2.slice(0, idx),\n            newItem,\n            ...list2.slice(idx + 1, list2.length)\n        ];\n    }\n    return [\n        ...list2\n    ];\n};\nconst $1819a5bdd3dcc96d$export$92b78acdbe066b6b = (array, getKey, getValue = (item)=>item)=>{\n    return array.reduce((acc, item)=>{\n        acc[getKey(item)] = getValue(item);\n        return acc;\n    }, {});\n};\nconst $1819a5bdd3dcc96d$export$2e6c959c16ff56b8 = (array, mapper, condition)=>{\n    if (!array) return [];\n    return array.reduce((acc, item, index)=>{\n        if (!condition(item, index)) return acc;\n        acc.push(mapper(item, index));\n        return acc;\n    }, []);\n};\nfunction $1819a5bdd3dcc96d$export$8960430cfd85939f(array, getter) {\n    const get = getter ?? ((v)=>v);\n    return $1819a5bdd3dcc96d$export$b1830edfb6732669(array, (a, b)=>get(a) > get(b) ? a : b);\n}\nfunction $1819a5bdd3dcc96d$export$96ec731ed4dcb222(array, getter) {\n    const get = getter ?? ((v)=>v);\n    return $1819a5bdd3dcc96d$export$b1830edfb6732669(array, (a, b)=>get(a) < get(b) ? a : b);\n}\nconst $1819a5bdd3dcc96d$export$54c7dfe5600eab89 = (list2, size = 2)=>{\n    const clusterCount = Math.ceil(list2.length / size);\n    return new Array(clusterCount).fill(null).map((_c, i)=>{\n        return list2.slice(i * size, i * size + size);\n    });\n};\nconst $1819a5bdd3dcc96d$export$7a5d5c156e7dc406 = (array, toKey)=>{\n    const valueMap = array.reduce((acc, item)=>{\n        const key = toKey ? toKey(item) : item;\n        if (acc[key]) return acc;\n        acc[key] = item;\n        return acc;\n    }, {});\n    return Object.values(valueMap);\n};\nfunction* $1819a5bdd3dcc96d$export$d02631cccf789723(startOrLength, end, valueOrMapper = (i)=>i, step = 1) {\n    const mapper = (0, $8ec73ad99a2999b4$export$f6e2535fb5126e54)(valueOrMapper) ? valueOrMapper : ()=>valueOrMapper;\n    const start = end ? startOrLength : 0;\n    const final = end ?? startOrLength;\n    for(let i = start; i <= final; i += step){\n        yield mapper(i);\n        if (i + step > final) break;\n    }\n}\nconst $1819a5bdd3dcc96d$export$8837f4fc672e936d = (startOrLength, end, valueOrMapper, step)=>{\n    return Array.from($1819a5bdd3dcc96d$export$d02631cccf789723(startOrLength, end, valueOrMapper, step));\n};\nconst $1819a5bdd3dcc96d$export$40fa977508bcf282 = (lists)=>{\n    return lists.reduce((acc, list2)=>{\n        acc.push(...list2);\n        return acc;\n    }, []);\n};\nconst $1819a5bdd3dcc96d$export$7b0a31e10bbff018 = (listA, listB, identity)=>{\n    if (!listA || !listB) return false;\n    const ident = identity ?? ((x)=>x);\n    const dictB = listB.reduce((acc, item)=>{\n        acc[ident(item)] = true;\n        return acc;\n    }, {});\n    return listA.some((value)=>dictB[ident(value)]);\n};\nconst $1819a5bdd3dcc96d$export$7a5058c6b79333e0 = (list2, condition)=>{\n    if (!list2) return [\n        [],\n        []\n    ];\n    return list2.reduce((acc, item)=>{\n        const [a, b] = acc;\n        if (condition(item)) return [\n            [\n                ...a,\n                item\n            ],\n            b\n        ];\n        else return [\n            a,\n            [\n                ...b,\n                item\n            ]\n        ];\n    }, [\n        [],\n        []\n    ]);\n};\nconst $1819a5bdd3dcc96d$export$4950aa0f605343fb = (root, others, matcher)=>{\n    if (!others && !root) return [];\n    if (!others) return root;\n    if (!root) return [];\n    if (!matcher) return root;\n    return root.reduce((acc, r)=>{\n        const matched = others.find((o)=>matcher(r) === matcher(o));\n        if (matched) acc.push(matched);\n        else acc.push(r);\n        return acc;\n    }, []);\n};\nconst $1819a5bdd3dcc96d$export$6f5a73e474c4c810 = (list2, newItem, match)=>{\n    if (!list2 && !newItem) return [];\n    if (!newItem) return [\n        ...list2\n    ];\n    if (!list2) return [\n        newItem\n    ];\n    for(let idx = 0; idx < list2.length; idx++){\n        const item = list2[idx];\n        if (match(item, idx)) return [\n            ...list2.slice(0, idx),\n            newItem,\n            ...list2.slice(idx + 1, list2.length)\n        ];\n    }\n    return [\n        ...list2,\n        newItem\n    ];\n};\nconst $1819a5bdd3dcc96d$export$e03c1c3201ee8bb7 = (list2, item, toKey, options)=>{\n    if (!list2 && !item) return [];\n    if (!list2) return [\n        item\n    ];\n    if (!item) return [\n        ...list2\n    ];\n    const matcher = toKey ? (x, idx)=>toKey(x, idx) === toKey(item, idx) : (x)=>x === item;\n    const existing = list2.find(matcher);\n    if (existing) return list2.filter((x, idx)=>!matcher(x, idx));\n    const strategy = options?.strategy ?? \"append\";\n    if (strategy === \"append\") return [\n        ...list2,\n        item\n    ];\n    return [\n        item,\n        ...list2\n    ];\n};\nconst $1819a5bdd3dcc96d$export$574ca932c3ade4d9 = (list2)=>{\n    return list2?.filter((x)=>!!x) ?? [];\n};\nconst $1819a5bdd3dcc96d$export$c1a059043cc9c119 = (count, func, initValue)=>{\n    let value = initValue;\n    for(let i = 1; i <= count; i++)value = func(value, i);\n    return value;\n};\nconst $1819a5bdd3dcc96d$export$a37e3c603d7117e5 = (root, other, identity = (t)=>t)=>{\n    if (!root?.length && !other?.length) return [];\n    if (root?.length === void 0) return [\n        ...other\n    ];\n    if (!other?.length) return [\n        ...root\n    ];\n    const bKeys = other.reduce((acc, item)=>{\n        acc[identity(item)] = true;\n        return acc;\n    }, {});\n    return root.filter((a)=>!bKeys[identity(a)]);\n};\nfunction $1819a5bdd3dcc96d$export$fba63a578e423eb(arr, n) {\n    if (arr.length === 0) return arr;\n    const shiftNumber = n % arr.length;\n    if (shiftNumber === 0) return arr;\n    return [\n        ...arr.slice(-shiftNumber, arr.length),\n        ...arr.slice(0, -shiftNumber)\n    ];\n}\n\n\nconst $3fba0bda95caa784$var$fish = [\n    {\n        name: \"Marlin\",\n        weight: 105\n    },\n    {\n        name: \"Bass\",\n        weight: 8\n    },\n    {\n        name: \"Trout\",\n        weight: 13\n    }\n];\nconst $3fba0bda95caa784$var$arr = (0, $1819a5bdd3dcc96d$export$97db5808d8f88186)($3fba0bda95caa784$var$fish, (f)=>f.weight) // => [bass, trout, marlin]\n;\nconsole.log($3fba0bda95caa784$var$arr);\n\n\n//# sourceMappingURL=index.ef2653c9.js.map\n","import { sort } from 'radash';\r\n\r\nimport { sort } from 'radash';\r\nconst fish = [\r\n  {\r\n    name: 'Marlin',\r\n    weight: 105\r\n  },\r\n  {\r\n    name: 'Bass',\r\n    weight: 8\r\n  },\r\n  {\r\n    name: 'Trout',\r\n    weight: 13\r\n  }\r\n]\r\nconst arr = sort(fish, f => f.weight) // => [bass, trout, marlin]\r\nconsole.log(arr)","import { isFunction, isArray } from './typed.mjs';\n\nconst group = (array, getGroupId) => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item);\n    if (!acc[groupId])\n      acc[groupId] = [];\n    acc[groupId].push(item);\n    return acc;\n  }, {});\n};\nfunction zip(...arrays) {\n  if (!arrays || !arrays.length)\n    return [];\n  return new Array(Math.max(...arrays.map(({ length }) => length))).fill([]).map((_, idx) => arrays.map((array) => array[idx]));\n}\nfunction zipToObject(keys, values) {\n  if (!keys || !keys.length) {\n    return {};\n  }\n  const getValue = isFunction(values) ? values : isArray(values) ? (_k, i) => values[i] : (_k, _i) => values;\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx);\n    return acc;\n  }, {});\n}\nconst boil = (array, compareFunc) => {\n  if (!array || (array.length ?? 0) === 0)\n    return null;\n  return array.reduce(compareFunc);\n};\nconst sum = (array, fn) => {\n  return (array || []).reduce(\n    (acc, item) => acc + (fn ? fn(item) : item),\n    0\n  );\n};\nconst first = (array, defaultValue = void 0) => {\n  return array?.length > 0 ? array[0] : defaultValue;\n};\nconst last = (array, defaultValue = void 0) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue;\n};\nconst sort = (array, getter, desc = false) => {\n  if (!array)\n    return [];\n  const asc = (a, b) => getter(a) - getter(b);\n  const dsc = (a, b) => getter(b) - getter(a);\n  return array.slice().sort(desc === true ? dsc : asc);\n};\nconst alphabetical = (array, getter, dir = \"asc\") => {\n  if (!array)\n    return [];\n  const asc = (a, b) => `${getter(a)}`.localeCompare(getter(b));\n  const dsc = (a, b) => `${getter(b)}`.localeCompare(getter(a));\n  return array.slice().sort(dir === \"desc\" ? dsc : asc);\n};\nconst counting = (list2, identity) => {\n  if (!list2)\n    return {};\n  return list2.reduce((acc, item) => {\n    const id = identity(item);\n    acc[id] = (acc[id] ?? 0) + 1;\n    return acc;\n  }, {});\n};\nconst replace = (list2, newItem, match) => {\n  if (!list2)\n    return [];\n  if (newItem === void 0)\n    return [...list2];\n  for (let idx = 0; idx < list2.length; idx++) {\n    const item = list2[idx];\n    if (match(item, idx)) {\n      return [\n        ...list2.slice(0, idx),\n        newItem,\n        ...list2.slice(idx + 1, list2.length)\n      ];\n    }\n  }\n  return [...list2];\n};\nconst objectify = (array, getKey, getValue = (item) => item) => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item);\n    return acc;\n  }, {});\n};\nconst select = (array, mapper, condition) => {\n  if (!array)\n    return [];\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index))\n      return acc;\n    acc.push(mapper(item, index));\n    return acc;\n  }, []);\n};\nfunction max(array, getter) {\n  const get = getter ?? ((v) => v);\n  return boil(array, (a, b) => get(a) > get(b) ? a : b);\n}\nfunction min(array, getter) {\n  const get = getter ?? ((v) => v);\n  return boil(array, (a, b) => get(a) < get(b) ? a : b);\n}\nconst cluster = (list2, size = 2) => {\n  const clusterCount = Math.ceil(list2.length / size);\n  return new Array(clusterCount).fill(null).map((_c, i) => {\n    return list2.slice(i * size, i * size + size);\n  });\n};\nconst unique = (array, toKey) => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : item;\n    if (acc[key])\n      return acc;\n    acc[key] = item;\n    return acc;\n  }, {});\n  return Object.values(valueMap);\n};\nfunction* range(startOrLength, end, valueOrMapper = (i) => i, step = 1) {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper;\n  const start = end ? startOrLength : 0;\n  const final = end ?? startOrLength;\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i);\n    if (i + step > final)\n      break;\n  }\n}\nconst list = (startOrLength, end, valueOrMapper, step) => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step));\n};\nconst flat = (lists) => {\n  return lists.reduce((acc, list2) => {\n    acc.push(...list2);\n    return acc;\n  }, []);\n};\nconst intersects = (listA, listB, identity) => {\n  if (!listA || !listB)\n    return false;\n  const ident = identity ?? ((x) => x);\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true;\n    return acc;\n  }, {});\n  return listA.some((value) => dictB[ident(value)]);\n};\nconst fork = (list2, condition) => {\n  if (!list2)\n    return [[], []];\n  return list2.reduce(\n    (acc, item) => {\n      const [a, b] = acc;\n      if (condition(item)) {\n        return [[...a, item], b];\n      } else {\n        return [a, [...b, item]];\n      }\n    },\n    [[], []]\n  );\n};\nconst merge = (root, others, matcher) => {\n  if (!others && !root)\n    return [];\n  if (!others)\n    return root;\n  if (!root)\n    return [];\n  if (!matcher)\n    return root;\n  return root.reduce((acc, r) => {\n    const matched = others.find((o) => matcher(r) === matcher(o));\n    if (matched)\n      acc.push(matched);\n    else\n      acc.push(r);\n    return acc;\n  }, []);\n};\nconst replaceOrAppend = (list2, newItem, match) => {\n  if (!list2 && !newItem)\n    return [];\n  if (!newItem)\n    return [...list2];\n  if (!list2)\n    return [newItem];\n  for (let idx = 0; idx < list2.length; idx++) {\n    const item = list2[idx];\n    if (match(item, idx)) {\n      return [\n        ...list2.slice(0, idx),\n        newItem,\n        ...list2.slice(idx + 1, list2.length)\n      ];\n    }\n  }\n  return [...list2, newItem];\n};\nconst toggle = (list2, item, toKey, options) => {\n  if (!list2 && !item)\n    return [];\n  if (!list2)\n    return [item];\n  if (!item)\n    return [...list2];\n  const matcher = toKey ? (x, idx) => toKey(x, idx) === toKey(item, idx) : (x) => x === item;\n  const existing = list2.find(matcher);\n  if (existing)\n    return list2.filter((x, idx) => !matcher(x, idx));\n  const strategy = options?.strategy ?? \"append\";\n  if (strategy === \"append\")\n    return [...list2, item];\n  return [item, ...list2];\n};\nconst sift = (list2) => {\n  return list2?.filter((x) => !!x) ?? [];\n};\nconst iterate = (count, func, initValue) => {\n  let value = initValue;\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i);\n  }\n  return value;\n};\nconst diff = (root, other, identity = (t) => t) => {\n  if (!root?.length && !other?.length)\n    return [];\n  if (root?.length === void 0)\n    return [...other];\n  if (!other?.length)\n    return [...root];\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true;\n    return acc;\n  }, {});\n  return root.filter((a) => !bKeys[identity(a)]);\n};\nfunction shift(arr, n) {\n  if (arr.length === 0)\n    return arr;\n  const shiftNumber = n % arr.length;\n  if (shiftNumber === 0)\n    return arr;\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)];\n}\n\nexport { alphabetical, boil, cluster, counting, diff, first, flat, fork, group, intersects, iterate, last, list, max, merge, min, objectify, range, replace, replaceOrAppend, select, shift, sift, sort, sum, toggle, unique, zip, zipToObject };\n//# sourceMappingURL=array.mjs.map\n","import { isArray, isFunction } from './typed'\n\n/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n): Partial<Record<Key, T[]>> => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * Ex. const zipped = zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]\n */\nexport function zip<T1, T2, T3, T4, T5>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[],\n  array5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[],\n  array4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3>(\n  array1: T1[],\n  array2: T2[],\n  array3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2>(array1: T1[], array2: T2[]): [T1, T2][]\nexport function zip<T>(...arrays: T[][]): T[][] {\n  if (!arrays || !arrays.length) return []\n  return new Array(Math.max(...arrays.map(({ length }) => length)))\n    .fill([])\n    .map((_, idx) => arrays.map(array => array[idx]))\n}\n\n/**\n * Creates an object mapping the specified keys to their corresponding values\n *\n * Ex. const zipped = zipToObject(['a', 'b'], [1, 2]) // { a: 1, b: 2 }\n * Ex. const zipped = zipToObject(['a', 'b'], (k, i) => k + i) // { a: 'a0', b: 'b1' }\n * Ex. const zipped = zipToObject(['a', 'b'], 1) // { a: 1, b: 1 }\n */\nexport function zipToObject<K extends string | number | symbol, V>(\n  keys: K[],\n  values: V | ((key: K, idx: number) => V) | V[]\n): Record<K, V> {\n  if (!keys || !keys.length) {\n    return {} as Record<K, V>\n  }\n\n  const getValue = isFunction(values)\n    ? values\n    : isArray(values)\n    ? (_k: K, i: number) => values[i]\n    : (_k: K, _i: number) => values\n\n  return keys.reduce((acc, key, idx) => {\n    acc[key] = getValue(key, idx)\n    return acc\n  }, {} as Record<K, V>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport const sum = <T extends number | object>(\n  array: readonly T[],\n  fn?: (item: T) => number\n) => {\n  return (array || []).reduce(\n    (acc, item) => acc + (fn ? fn(item) : (item as number)),\n    0\n  )\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  if (!list) return {} as Record<TId, number>\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    acc[id] = (acc[id] ?? 0) + 1\n    return acc\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (newItem === undefined) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce((acc, item) => {\n    acc[getKey(item)] = getValue(item)\n    return acc\n  }, {} as Record<Key, Value>)\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * @example\n * select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T, index: number) => K,\n  condition: (item: T, index: number) => boolean\n) => {\n  if (!array) return []\n  return array.reduce((acc, item, index) => {\n    if (!condition(item, index)) return acc\n    acc.push(mapper(item, index))\n    return acc\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * @example\n * max([ 2, 3, 5]) == 5\n * max([{ num: 1 }, { num: 2 }], x => x.num) == { num: 2 }\n */\nexport function max(array: readonly [number, ...number[]]): number\nexport function max(array: readonly number[]): number | null\nexport function max<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function max<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * @example\n * min([1, 2, 3, 4]) == 1\n * min([{ num: 1 }, { num: 2 }], x => x.num) == { num: 1 }\n */\nexport function min(array: readonly [number, ...number[]]): number\nexport function min(array: readonly number[]): number | null\nexport function min<T>(\n  array: readonly T[],\n  getter: (item: T) => number\n): T | null\nexport function min<T>(\n  array: readonly T[],\n  getter?: (item: T) => number\n): T | null {\n  const get = getter ?? ((v: any) => v)\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    acc[key] = item\n    return acc\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example\n * range(3)                  // yields 0, 1, 2, 3\n * range(0, 3)               // yields 0, 1, 2, 3\n * range(0, 3, 'y')          // yields y, y, y, y\n * range(0, 3, () => 'y')    // yields y, y, y, y\n * range(0, 3, i => i)       // yields 0, 1, 2, 3\n * range(0, 3, i => `y${i}`) // yields y0, y1, y2, y3\n * range(0, 3, obj)          // yields obj, obj, obj, obj\n * range(0, 6, i => i, 2)    // yields 0, 2, 4, 6\n */\nexport function* range<T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper: T | ((i: number) => T) = i => i as T,\n  step: number = 1\n): Generator<T> {\n  const mapper = isFunction(valueOrMapper) ? valueOrMapper : () => valueOrMapper\n  const start = end ? startOrLength : 0\n  const final = end ?? startOrLength\n  for (let i = start; i <= final; i += step) {\n    yield mapper(i)\n    if (i + step > final) break\n  }\n}\n\n/**\n * Creates a list of given start, end, value, and\n * step parameters.\n *\n * @example\n * list(3)                  // 0, 1, 2, 3\n * list(0, 3)               // 0, 1, 2, 3\n * list(0, 3, 'y')          // y, y, y, y\n * list(0, 3, () => 'y')    // y, y, y, y\n * list(0, 3, i => i)       // 0, 1, 2, 3\n * list(0, 3, i => `y${i}`) // y0, y1, y2, y3\n * list(0, 3, obj)          // obj, obj, obj, obj\n * list(0, 6, i => i, 2)    // 0, 2, 4, 6\n */\nexport const list = <T = number>(\n  startOrLength: number,\n  end?: number,\n  valueOrMapper?: T | ((i: number) => T),\n  step?: number\n): T[] => {\n  return Array.from(range(startOrLength, end, valueOrMapper, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    acc.push(...list)\n    return acc\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce((acc, item) => {\n    acc[ident(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) acc.push(matched)\n    else acc.push(r)\n    return acc\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\ntype Falsy = null | undefined | false | '' | 0 | 0n\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly (T | Falsy)[]): T[] => {\n  return (list?.filter(x => !!x) as T[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce((acc, item) => {\n    acc[identity(item)] = true\n    return acc\n  }, {} as Record<string | number | symbol, boolean>)\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n","const isSymbol = (value) => {\n  return !!value && value.constructor === Symbol;\n};\nconst isArray = Array.isArray;\nconst isObject = (value) => {\n  return !!value && value.constructor === Object;\n};\nconst isPrimitive = (value) => {\n  return value === void 0 || value === null || typeof value !== \"object\" && typeof value !== \"function\";\n};\nconst isFunction = (value) => {\n  return !!(value && value.constructor && value.call && value.apply);\n};\nconst isString = (value) => {\n  return typeof value === \"string\" || value instanceof String;\n};\nconst isInt = (value) => {\n  return isNumber(value) && value % 1 === 0;\n};\nconst isFloat = (value) => {\n  return isNumber(value) && value % 1 !== 0;\n};\nconst isNumber = (value) => {\n  try {\n    return Number(value) === value;\n  } catch {\n    return false;\n  }\n};\nconst isDate = (value) => {\n  return Object.prototype.toString.call(value) === \"[object Date]\";\n};\nconst isPromise = (value) => {\n  if (!value)\n    return false;\n  if (!value.then)\n    return false;\n  if (!isFunction(value.then))\n    return false;\n  return true;\n};\nconst isEmpty = (value) => {\n  if (value === true || value === false)\n    return true;\n  if (value === null || value === void 0)\n    return true;\n  if (isNumber(value))\n    return value === 0;\n  if (isDate(value))\n    return isNaN(value.getTime());\n  if (isFunction(value))\n    return false;\n  if (isSymbol(value))\n    return false;\n  const length = value.length;\n  if (isNumber(length))\n    return length === 0;\n  const size = value.size;\n  if (isNumber(size))\n    return size === 0;\n  const keys = Object.keys(value).length;\n  return keys === 0;\n};\nconst isEqual = (x, y) => {\n  if (Object.is(x, y))\n    return true;\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime();\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString();\n  }\n  if (typeof x !== \"object\" || x === null || typeof y !== \"object\" || y === null) {\n    return false;\n  }\n  const keysX = Reflect.ownKeys(x);\n  const keysY = Reflect.ownKeys(y);\n  if (keysX.length !== keysY.length)\n    return false;\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y, keysX[i]))\n      return false;\n    if (!isEqual(x[keysX[i]], y[keysX[i]]))\n      return false;\n  }\n  return true;\n};\n\nexport { isArray, isDate, isEmpty, isEqual, isFloat, isFunction, isInt, isNumber, isObject, isPrimitive, isPromise, isString, isSymbol };\n//# sourceMappingURL=typed.mjs.map\n","export const isSymbol = (value: any): value is symbol => {\n  return !!value && value.constructor === Symbol\n}\n\nexport const isArray = Array.isArray\n\nexport const isObject = (value: any): value is object => {\n  return !!value && value.constructor === Object\n}\n\n/**\n * Checks if the given value is primitive.\n *\n * Primitive Types: number , string , boolean , symbol, bigint, undefined, null\n *\n * @param {*} value value to check\n * @returns {boolean} result\n */\nexport const isPrimitive = (value: any): boolean => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value !== 'object' && typeof value !== 'function')\n  )\n}\n\nexport const isFunction = (value: any): value is Function => {\n  return !!(value && value.constructor && value.call && value.apply)\n}\n\nexport const isString = (value: any): value is string => {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport const isInt = (value: any): value is number => {\n  return isNumber(value) && value % 1 === 0\n}\n\nexport const isFloat = (value: any): value is number => {\n  return isNumber(value) && value % 1 !== 0\n}\n\nexport const isNumber = (value: any): value is number => {\n  try {\n    return Number(value) === value\n  } catch {\n    return false\n  }\n}\n\nexport const isDate = (value: any): value is Date => {\n  return Object.prototype.toString.call(value) === '[object Date]'\n}\n\n/**\n * This is really a _best guess_ promise checking. You\n * should probably use Promise.resolve(value) to be 100%\n * sure you're handling it correctly.\n */\nexport const isPromise = (value: any): value is Promise<any> => {\n  if (!value) return false\n  if (!value.then) return false\n  if (!isFunction(value.then)) return false\n  return true\n}\n\nexport const isEmpty = (value: any) => {\n  if (value === true || value === false) return true\n  if (value === null || value === undefined) return true\n  if (isNumber(value)) return value === 0\n  if (isDate(value)) return isNaN(value.getTime())\n  if (isFunction(value)) return false\n  if (isSymbol(value)) return false\n  const length = (value as any).length\n  if (isNumber(length)) return length === 0\n  const size = (value as any).size\n  if (isNumber(size)) return size === 0\n  const keys = Object.keys(value).length\n  return keys === 0\n}\n\nexport const isEqual = <TType>(x: TType, y: TType): boolean => {\n  if (Object.is(x, y)) return true\n  if (x instanceof Date && y instanceof Date) {\n    return x.getTime() === y.getTime()\n  }\n  if (x instanceof RegExp && y instanceof RegExp) {\n    return x.toString() === y.toString()\n  }\n  if (\n    typeof x !== 'object' ||\n    x === null ||\n    typeof y !== 'object' ||\n    y === null\n  ) {\n    return false\n  }\n  const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[]\n  const keysY = Reflect.ownKeys(y as unknown as object)\n  if (keysX.length !== keysY.length) return false\n  for (let i = 0; i < keysX.length; i++) {\n    if (!Reflect.has(y as unknown as object, keysX[i])) return false\n    if (!isEqual(x[keysX[i]], y[keysX[i]])) return false\n  }\n  return true\n}\n"],"names":["console","log","array","getter","desc","slice","sort","a","b","name","weight","f","list"],"version":3,"file":"index.ef2653c9.js.map"}